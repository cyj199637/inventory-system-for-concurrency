## 낙관적 락

JPA가 제공하는 낙관적 락은 `@Version` 을 사용한다.

따라서 낙관적 락을 사용하려면 `@Version` 어노테이션으로 버전 관리 기능을 추가해야 한다.

* `@Version`
  * 엔티티를 수정할 때마다 버전이 하나씩 자동 증가
    * 단, 연관관계 필드는 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 버전이 증가한다.
  * 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외 발생
  * 버전 비교 방법
    * 엔티티를 수정하고 트랜잭션을 커밋하면 영속성 컨텍스트를 플러시하면서 버전 업데이트 쿼리를 실행한다. 이때 버전을 사용하는 엔티티면 검색 조건에 엔티티의 버전 정보를 추가한다.
    ~~~sql
    UPDATE stock
    SET
        quantity = ?
        version = ?    -- 버전 + 1 증가
    WHERE
        id = ?
        version = ?    -- 버전 비교
    ~~~
    * 데이터베이스 버전과 엔티티 버전이 같으면 데이터를 수정하면서 동시에 버전도 증가시킨다.
    * 데이터베이스 버전과 엔티티 버전이 다르면 WHERE 절에서 걸러져서 수정할 대상이 없어지므로 JPA가 예외를 발생시킨다.

<br/>

* 특징 
  * 트랜잭션을 커밋하는 시점에 충돌을 알 수 있다.

<br/>

* 장점: 별도의 락을 잡지 않으므로 성능상 이점이 있다.
* 단점: 쓰기 작업 실패 시, 재시도 로직을 직접 작성해야 한다.

<br/>

* 발생하는 예외 
  * OptimisticLockException(JPA 예외)
  * StaleObjectStateException(하이버네이트 예외)
  * ObjectOptimisticLockingFailureException(스프링 예외 추상화)

<br/>

### NONE
락 옵션을 적용하지 않아도 엔티티에 `@Version` 이 적용된 필드만 있으면 낙관적 락이 적용된다.

* 용도
  * 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경(삭제)되지 않아야 한다.
  * 조회 시점부터 수정 시점까지 보장한다.
* 동작
  * 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다.(UPDATE 쿼리 사용)
  * 이때 데이터베이스의 버전 값이 현재 버전이 아니면 예외가 발생한다.
* 이점
  * 두 번의 갱신 분실 문제를 예방한다.
    * 두 번의 갱신 분실 문제
      
      -> 두 명의 사용자가 같은 데이터를 수정할 때, 먼저 완료한 사용자의 수정사항은 사라지고 나중에 완료한 사용자의 수정사항만 남게되는 문제

<br/>

### OPTIMISTIC
`@Version` 만 적용했을 때는 엔티티를 수정해야 버전을 체크하지만 이 옵션을 추가하면 엔티티를 조회만 해도 버전을 체크한다.

즉, 한 번 조회한 엔티티는 트랜잭션을 종료할 때까지 다른 트랜잭션에서 변경하지 않음을 보장한다.

* 용도
  * 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변경되지 않아야 한다.
  * 조회 시점부터 트랜잭션이 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다.
* 동작
  * 트랜잭션을 커밋할 때 버전 정보를 조회해서 현재 엔티티의 버전과 같은지 검증한다. 
    
    -> 만약 같지 않으면 예외가 발생
* 이점
  * `DIRTY READ` 와 `NONE-REPEATABLE READ` 를 방지

<br/>

### OPTIMISTIC_FORCE_INCREMENT
낙관적 락을 사용하면서 버전 정보를 강제로 증가한다.

* 용도
  * 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
  * ex) 게시물과 첨부파일이 일대다, 다대일의 양방향 연관관계이고 첨부파일이 연관관계의 주인일 때,
    
    -> 게시물을 수정하는 데 단순히 첨부파일만 추가하면 게시물의 버전은 증가하지 않는다. 

    -> 해당 게시물은 물리적으로는 변경되지 않았지만, 논리적으로는 변경되었다.

    -> 이때 게시물의 버전도 강제로 증가하려면 이 옵션을 사용한다.
* 동작
  * 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가시킨다.
  * 이때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외가 발생한다.
  * 추가로 엔티티를 수정하면 수정 시 버전 UPDATE가 발생한다. 따라서 총 2번의 버전 증가가 나타날 수 있다.
* 이점
  * 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다.